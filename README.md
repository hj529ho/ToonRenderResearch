# 카툰렌더링에 대한 조사
![0.gif](/Images/0.gif)

## 목차
[1. 렌더링 파이프라인](#1-렌더링-파이프라인)<br>
[2. 사전 준비](#2-사전-준비)<br>
[3. 아웃라인 쉐이더](#3-아웃라인-쉐이더)<br>
[4. 노멀과 라이트의 내적](#4-노멀과-라이트의-내적)<br>
[5. 하프 램버트](#5-하프-램버트)<br>
[6. 계산된 하프 램버트 값에 따른 색깔 적용](#6-계산된-하프-램버트-값에-따른-색깔-적용)<br>
[7. 림라이트](#7-림라이트)<br>
[8. 중색 배색](#8-중색-배색)</br><br>
[EX-1 SDF 쉐이더](#ex-1-sdf-쉐이더)<br>


## 1. 렌더링 파이프라인
카툰 렌더링을 만들기 위해서는 기본적으로 렌더링 파이프라인에 대한 이해가 필요하다.

렌더링 파이프라인은 기본적으로 다음과 같은 순서로 이루워진다.
- Input Assembler
- Vertex Shader
- Rasterization
- Fragment Shader
### Input Assembler
Input Assembler 단계는 CPU가 렌더링을 수행할 도형의 정점 정보를 vertex buffer에 담아 GPU에 전달하는 과정이다.</br>
### Vertex Shader
vertex buffer에 담겨있던 정점의 3D좌표를 2D로 변환하는 과정이다.
이 과정을 통해 카메라에 그려질 vertex를 가려낸다.
### Rasterization
vertex shader에서 변환된 2D좌표를 화면에 표시될 픽셀로 변환하는 과정이다.
보간법을 사용하여 각 픽셀을 결정하며 이 과정은 프로그래밍 불가능하다.
### Fragment Shader
래스터화된 도형의 픽셀에 색을 입히는 과정이다.
매핑, 라이팅등의 처리를 할 수 있다.


카툰 렌더링을 하기 위해서 VertexShader, Fragment Shader를 작성해야한다.


## 2. 사전 준비

~~준비된 모델은 니케 홈페이지의 MMD모델을 유니티에 임포트하였다.~~ </br>
~~모든 매터리얼은 Unlit 쉐이더를 적용하여 적절한 텍스쳐를 입혀주었다.~~ </br>
해당 포스트의 작성이 길어져 본격적인 쉐이더 부분은 유니티 기본 Sphere로 대체하였다.
![1.png](/Images/1.png)

## 3. 아웃라인 쉐이더
카툰 렌더링은 3D오브젝트를 CellAnimation 기법의 2D처럼 보이게 하는 것이 목적이다. 따라서 뚜렷한 외곽선을 보여줄 필요가 있었다.

캐릭터의 외곽선을 표현하기에 가장 단순한 방법은 조금 더 큰 크기의 검정색 캐릭터를 원본 캐릭터와 겹쳐놓는 방법이다.

캐릭터의 피봇을 기준으로 확대를 하게되면 외곽선이 아니라 단순히 모델이 겹쳐있는 것으로 보일 것이다.
![2.png](/Images/2.png)
[이런 느낌이다.]

이를 해결할 방법중 하나로 캐릭터의 표면(노말)을 기준으로 확장하고 Back face로 렌더링하는 방법이 있다.
![3.png](/Images/3.png)

하지만 이 방법은 날카로운 엣지에서는 다음과 같은 문제가 생긴다.
![4.png](/Images/4.png)
[유니티 로고 같이 생겼다]

노말 방향으로만 확장하기 때문에 엣지부분이 "아웃라인"처럼 보이지 않게 된다.

**해결 : Smooth Normal**

하드엣지로 분리된 버텍스들의 노멀을 평균 내서 부드러운 노멀을 만들면 이 문제를 해결할 수 있다.
계산된 Smooth Normal은 탄젠트 채널에 저장해두고, 아웃라인 셰이더에서 이 값을 사용하여 버텍스를 확장한다.

> **참고:** 탄젠트 채널은 본래 노멀맵 변환에 사용되므로, 노멀맵이 필요한 메시라면 Smooth Normal은 여분의 UV 채널 등 다른 곳에 저장해야 한다.


```C#
    public Mesh mesh;
    void smoothNormals()
    {
        // 같은 위치의 정점들을 그룹핑
        var smoothNormals = new Dictionary<Vector3, Vector3>();
        
        for (int i = 0; i < mesh.vertexCount; i++)
        {
            var pos = mesh.vertices[i];
            if (!smoothNormals.ContainsKey(pos))
                smoothNormals[pos] = Vector3.zero;
            smoothNormals[pos] += mesh.normals[i]; // 노말 누적
        }
        
        // 평균 내서 탄젠트 채널에 저장
        var tangents = new Vector4[mesh.vertexCount];
        for (int i = 0; i < mesh.vertexCount; i++)
        {
            var avg = smoothNormals[mesh.vertices[i]].normalized;
            tangents[i] = new Vector4(avg.x, avg.y, avg.z, 0);
        }
        mesh.tangents = tangents;
    }
```
이 코드는 임포트시에 사용하면 될 것으로 추측된다.(이 문장은 이후의 실험 후에 수정하겠음)

![5.png](/Images/5.png)

계산된 Smooth Normal을 기존의 Normal과 대체하면 

![6.png](/Images/6.png)
하드엣지에서 갈라지지 않는 깔끔한 아웃라인을 얻을 수 있다.

## 4. 노멀과 라이트의 내적

### Normal Vector
normal vector는 법선벡터, 즉 면의 방향을 의미한다.
컴퓨터 그래픽스에서 면은 3개의 점과 법선벡터로 이루워져있다.
법선 벡터는 두 벡터간의 외적으로 구할 수 있다.(외적 순서의 따라 방향이 반대)

### 내적
벡터의 내적의 기하학적 의미는 한 벡터를 다른 벡터위에 Projection 한 길이라고 할 수 있다.

> **dot(A,B) = |A| * |B| * cos(θ)**

위의 식을 풀어보면 B위에 A를 투영했을때 그 그림자(|A| * cos(θ))위에
B의 길이를 곱한 값이다.

따라서 내적이 알려주는건 두 벡터의 방향이 얼마나 유사한가를 스칼라로 표현한 것이다.

여기서 A와 B가 길이가 1인 단위벡터일때 dot(A,B)는 cos(θ)로 단순화 할 수 있다.

### 코사인
![7.png](/Images/7.png)

코사인은 θ가 0일때 1, 90일때 0이며 파동하는 성질이 있다.

여기서 노말과 라이트를 대입해서 생각해보면 라이트가 노말의 각이 가까울수록 1 멀수록 -1 

이것을 직접 적용하면 램버트쉐이더라고 한다.
![8.png](/Images/8.png)

## 5. 하프 램버트
기존 램버트 쉐이더는 0 이하가 전부 검정으로 잘리면서 매쉬으 어두운 면이 디테일없이 0으로 뭉개져버린다.

따라서 HalfLambert는 이 값을 0~1 범위로 리매핑 하는 것이다.

> **halfLambert = dot(N,L) * 0.5 +0.5**

이렇게 되면 원래 뒷면이던 -1도 0, 정면은 그대로 1로 유지 되어 어두운 영역에 그라데이션이 생긴다.

![9.png](/Images/9.png)

## 6. 계산된 하프 램버트 값에 따른 색깔 적용

카툰 렌더링의 핵심은 이 계산된 하프 램버트 값을 바탕으로 단계별 색상을 적용하는 것이다.
크게 하이라이트/베이스컬러/그림자 3단계로 나눌 수 있다.
순서대로 하프램버트의 값이 높은 순대로 적용할 수 있다 
0~1의 범위기 때문에 1~0.9는 하이라이트, 0.3이하는 그림자 이런식으로 만들 수 있다.

![10.png](/Images/10.png)

## 7. 림라이트

림라이트는 기존의 조명과 다른 방식으로 개발한다.

림라이트는 조명의 영향을 받기보단 외곽선에 가깝기 때문에 카메라로부터 외곽쪽인 부분을 찾아야한다.
따라서 카메라 방향과 노말이 수직(cosθ == 0)에 가까울수록 가장자리라는 계산을 할 수 있다.
이때 카메라의 방향은 View 좌표계이기 때문에 Object 좌표계로 변환해주어야한다.

![11.png](/Images/11.png)


## 8. 중색 배색
![12.png](/Images/12.png)
특정한 구간을 정해서 SmoothStep을 통해 그라데이션을 만들면 중색 배색도 가능하다.
![13.png](/Images/13.png)
쉐도우 컬러와 베이스컬러를 그라데이션


## EX-1 SDF 쉐이더
<추가중>
